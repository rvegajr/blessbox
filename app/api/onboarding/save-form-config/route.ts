import { NextRequest, NextResponse } from 'next/server';
import { FormConfigService } from '@/lib/services/FormConfigService';
import { MembershipService } from '@/lib/services/MembershipService';
import { getServerSession } from '@/lib/auth-helper';
import { getDbClient } from '@/lib/db';
import { v4 as uuidv4 } from 'uuid';
import QRCode from 'qrcode';

const formConfigService = new FormConfigService();
const membershipService = new MembershipService();
const db = getDbClient();

export async function POST(request: NextRequest) {
  try {
    // Require authentication
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { organizationId, formFields, language = 'en', name = 'Registration Form', autoGenerateDefaultQR = false } = body;

    // Validate inputs
    if (!organizationId || typeof organizationId !== 'string') {
      return NextResponse.json(
        { success: false, error: 'Organization ID is required' },
        { status: 400 }
      );
    }

    if (!Array.isArray(formFields)) {
      return NextResponse.json(
        { success: false, error: 'Form fields must be an array' },
        { status: 400 }
      );
    }

    // Require membership for organization
    const isMember = await membershipService.isMember(session.user.id, organizationId);
    if (!isMember) {
      return NextResponse.json({ success: false, error: 'Forbidden' }, { status: 403 });
    }

    // Check if form config already exists for this organization
    const existing = await formConfigService.getFormConfigByOrganization(organizationId);

    let config;
    if (existing) {
      // Update existing config
      config = await formConfigService.updateFormConfig(existing.id, {
        formFields,
        language,
        name,
      });
    } else {
      // Create new config
      config = await formConfigService.createFormConfig({
        organizationId,
        name,
        language,
        formFields,
      });
    }

    // Auto-generate a default QR code ONLY if:
    // 1. No QR codes exist yet
    // 2. This is a brand new form config (not an update)
    // This ensures users can edit forms without triggering auto-generation
    try {
      const qrSetResult = await db.execute({
        sql: `SELECT qr_codes FROM qr_code_sets WHERE id = ?`,
        args: [config.id],
      });

      let existingQrCodes = [];
      if (qrSetResult.rows.length > 0) {
        try {
          existingQrCodes = JSON.parse((qrSetResult.rows[0] as any).qr_codes || '[]');
        } catch (parseError) {
          console.error('Failed to parse existing QR codes:', parseError);
        }
      }

      // Only auto-generate if:
      // - No QR codes exist AND
      // - This was a new form config creation (not an update) AND
      // - autoGenerateDefaultQR flag is explicitly true
      if (existingQrCodes.length === 0 && !existing && autoGenerateDefaultQR) {
        console.log(`üîß Auto-generating default QR code for organization ${organizationId}`);
        
        // Get organization details for slug
        const orgResult = await db.execute({
          sql: `SELECT id, name, custom_domain FROM organizations WHERE id = ?`,
          args: [organizationId],
        });

        if (orgResult.rows.length > 0) {
          const org = orgResult.rows[0] as any;
          const orgSlug = org.custom_domain || org.name.toLowerCase().replace(/\s+/g, '-');

          // Generate a default "main-entrance" QR code
          const baseUrl =
            process.env.PUBLIC_APP_URL ||
            process.env.NEXTAUTH_URL ||
            process.env.NEXT_PUBLIC_APP_URL ||
            (process.env.NEXT_PUBLIC_VERCEL_URL ? `https://${process.env.NEXT_PUBLIC_VERCEL_URL}` : 'http://localhost:7777');

          const defaultSlug = 'main-entrance';
          const qrCodeId = uuidv4();
          const registrationUrl = `${baseUrl}/register/${orgSlug}/${defaultSlug}`;

          console.log(`  Registration URL: ${registrationUrl}`);

          // Generate QR code image
          const qrDataUrl = await QRCode.toDataURL(registrationUrl, {
            errorCorrectionLevel: 'M',
            margin: 1,
            width: 256,
            color: {
              dark: '#667eea',
              light: '#ffffff',
            },
          });

          const defaultQrCode = {
            id: qrCodeId,
            label: defaultSlug,
            slug: defaultSlug,
            url: registrationUrl,
            dataUrl: qrDataUrl,
            description: 'Main Entrance',
          };

          // Update QR code set with the default QR code
          const now = new Date().toISOString();
          await db.execute({
            sql: `UPDATE qr_code_sets SET qr_codes = ?, updated_at = ? WHERE id = ?`,
            args: [JSON.stringify([defaultQrCode]), now, config.id],
          });

          console.log(`‚úÖ Auto-generated default QR code for organization ${organizationId}`);
        } else {
          console.error(`‚ùå Organization ${organizationId} not found for QR generation`);
        }
      } else {
        console.log(`‚ÑπÔ∏è  Skipping auto-generation: ${existingQrCodes.length} QR codes already exist`);
      }
    } catch (qrError) {
      console.error('‚ùå Auto-QR generation failed:', qrError);
      // Don't fail the whole request if QR generation fails
    }

    return NextResponse.json({
      success: true,
      message: 'Form configuration saved successfully',
      config: {
        id: config.id,
        name: config.name,
        language: config.language,
        formFields: config.formFields,
      },
    });
  } catch (error) {
    console.error('Save form config error:', error);
    
    // Handle specific error types
    if (error instanceof Error) {
      if (error.message.includes('Organization not found')) {
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 404 }
        );
      }
      
      if (error.message.includes('Validation failed')) {
        return NextResponse.json(
          { success: false, error: error.message },
          { status: 400 }
        );
      }
    }
    
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Internal server error' 
      },
      { status: 500 }
    );
  }
}
